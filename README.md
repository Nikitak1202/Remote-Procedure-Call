# Remote Procedure Call

## Обзор

Этот проект реализует многоуровневый протокол Remote Procedure Call (RPC) для микроконтроллерной платформы ESP32. Протокол разделён на четыре слоя:

1. **Физический слой** – обеспечивает передачу байтов по UART. Реализация использует драйвер `uart` из ESP-IDF и обеспечивает базовые функции `physical_send` и `physical_receive_byte`. Инициализация настраивает скорость, формат кадра (8N1), пины TX/RX.  
2. **Канальный слой** – отвечает за формирование кадров, добавление служебных байтов и CRC8. Формат кадра включает стартовый байт, длину, CRC заголовка, байт начала данных, полезную нагрузку, CRC полезных данных и стоп-байт. Приёмник реализует конечный автомат, который отбрасывает повреждённые или неполные кадры.  
3. **Транспортный слой** – реализует RPC: отправку запросов, ожидание ответа или ошибки, диспетчеризацию входящих запросов по зарегистрированным функциям. Поддерживаются типы сообщений:
   - `0x0B` — Request  
   - `0x16` — Response  
   - `0x21` — Error  
   Для каждого запроса используется счётчик (counter) для сопоставления с ответом. В текущей версии допускается только один активный вызов.
4. **Прикладной слой** – содержит конкретные RPC-функции, которые можно вызывать по имени. В примере реализованы:
   - `sum` — принимает два числа `uint32_t` в формате little-endian, возвращает их сумму в текстовом виде.  
   - `echo` — возвращает строку/данные, полученные в аргументах.  

Организация памяти основана на `pvPortMalloc/vPortFree` (FreeRTOS-аллокатор). Все буферы ответа выделяются в обработчике и освобождаются транспортным уровнем после отправки.  

На стороне клиента предоставляется синхронный вызов `transport_call`, который блокируется до получения ответа или таймаута. На стороне сервера работает задача `transport_receiver_task`, которая принимает кадры и вызывает соответствующие зарегистрированные функции.

---

## Недостатки протокола и предложения по улучшению

### Недостатки протокола
1. **CRC8 для всего кадра** — слишком слабая защита для длинных пакетов.
2. **Имена функций в ASCII** — неэффективно и создаёт риск ошибок (регистр букв, длина строки).
3. **Один активный вызов** — текущая реализация транспорта поддерживает только один запрос в работе.
4. **Отсутствие механизма подтверждений/повторов** — потеря пакета приводит к таймауту.
5. **Нет защиты (шифрование/аутентификация)** — протокол небезопасен в потенциально неблагоприятных условиях.  

### Предложения по улучшению
1. **CRC16 или CRC32** — надёжнее при реальных нагрузках, но занимают больше байт.    
3. **Использовать числовые идентификаторы функций** — вместо строк, для компактности и скорости.  
4. **Многократные параллельные вызовы** — таблица ожиданий с привязкой counter → очередь.
5. **Безопасность** — добавить опциональное шифрование и аутентификацию (например, AES + HMAC).  

---

## Возможные улучшения реализации

1. **Многократные вызовы**.  
   В текущем транспорте глобальная переменная `pending_queue` ограничивает использование только одним запросом. Улучшение: реализовать таблицу ожиданий (map: counter → очередь). Это позволит параллельно вызывать несколько RPC из разных задач FreeRTOS.  

2. **Коды ошибок**.  
   Сейчас используются только `ERR_FUNC_NOT_FOUND` и `ERR_INTERNAL`. Улучшение: расширить перечень кодов ошибок (например, «недопустимые аргументы», «таймаут исполнения функции», «недостаточно памяти»).  
  
3. **Логирование и диагностика**.  
   Добавить отладочные сообщения в transport/link слои (например, через ESP-IDF logging), чтобы облегчить поиск проблем.  

4. **Явные лимиты**.  
   Сейчас задачи не защищены от некорректного ввода (например, слишком длинных имён функций). Улучшение: добавить защиту от переполнения буфера и явные лимиты.  
