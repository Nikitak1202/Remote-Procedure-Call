# Remote Procedure Call

## Обзор

Этот проект реализует многоуровневый протокол Remote Procedure Call (RPC) для микроконтроллерной платформы ESP32. Протокол разделён на четыре слоя:

1. **Физический слой** – обеспечивает передачу байтов по UART. Реализация использует драйвер `uart` из ESP-IDF и обеспечивает базовые функции `physical_send` и `physical_receive_byte`. Инициализация настраивает скорость, формат кадра (8N1), пины TX/RX.  
2. **Канальный слой** – отвечает за формирование кадров, добавление служебных байтов и CRC8. Формат кадра включает стартовый байт, длину, CRC заголовка, байт начала данных, полезную нагрузку, CRC полезных данных и стоп-байт. Приёмник реализует конечный автомат, который отбрасывает повреждённые или неполные кадры.  
3. **Транспортный слой** – реализует RPC: отправку запросов, ожидание ответа или ошибки, диспетчеризацию входящих запросов по зарегистрированным функциям. Поддерживаются типы сообщений:
   - `0x0B` — Request  
   - `0x0C` — Stream (пока зарезервировано)  
   - `0x16` — Response  
   - `0x21` — Error  
   Для каждого запроса используется счётчик (counter) для сопоставления с ответом. Реализовано ограничение: в текущей версии допускается только один активный вызов.  
4. **Прикладной слой** – содержит конкретные RPC-функции, которые можно вызывать по имени. В примере реализованы:
   - `sum` — принимает два числа `uint32_t` в формате little-endian, возвращает их сумму в текстовом виде.  
   - `echo` — возвращает строку/данные, полученные в аргументах.  

Организация памяти основана на `pvPortMalloc/vPortFree` (FreeRTOS-аллокатор). Все буферы ответа выделяются в обработчике и освобождаются транспортным уровнем после отправки.  

На стороне клиента предоставляется синхронный вызов `transport_call`, который блокируется до получения ответа или таймаута. На стороне сервера работает задача `transport_receiver_task`, которая принимает кадры и вызывает соответствующие зарегистрированные функции.

---

## Недостатки протокола и предложения по улучшению

### Недостатки протокола
1. **CRC8 для всего кадра** — слишком слабая защита для длинных пакетов.  
2. **Нет версии протокола** — несовместимости в будущем будет трудно отлавливать.  
3. **Имена функций в ASCII** — неэффективно и создаёт риск ошибок (регистр букв, длина строки).  
4. **Один активный вызов** — текущая реализация транспорта поддерживает только один запрос в работе.  
5. **Отсутствие механизма подтверждений/повторов** — потеря пакета приводит к таймауту.  
6. **Нет защиты (шифрование/аутентификация)** — протокол небезопасен в потенциально неблагоприятных условиях.  
7. **Нет кода состояния в Response** — успех определяется только фактом прихода ответа; ошибки передаются отдельным типом сообщения.

### Предложения по улучшению
1. **CRC16 или CRC32** — надёжнее при реальных нагрузках.  
2. **Добавить поле версии протокола** — упростит расширение формата в будущем.  
3. **Использовать числовые идентификаторы функций** — вместо строк, для компактности и скорости.  
4. **Многократные параллельные вызовы** — таблица ожиданий с привязкой counter → очередь.  
5. **Stream-сообщения** — реализовать, чтобы поддерживать однонаправленные push-уведомления (например, телеметрия).  
6. **Подтверждения (ACK) и повторы** — повысит надёжность передачи в неблагоприятных условиях.  
7. **Безопасность** — добавить опциональное шифрование и аутентификацию (например, AES + HMAC).  

---

## Возможные улучшения реализации

1. **Многократные вызовы**.  
   В текущем транспорте глобальная переменная `pending_queue` ограничивает использование только одним запросом. Улучшение: реализовать таблицу ожиданий (map: counter → очередь). Это позволит параллельно вызывать несколько RPC из разных задач FreeRTOS.  

2. **Унификация аллокатора**.  
   В проекте заменены `malloc/free` на `pvPortMalloc/vPortFree`. Это правильно: память теперь учитывается в менеджере FreeRTOS. Улучшение: добавить слой-обёртку для отслеживания утечек и статистики.  

3. **Коды ошибок**.  
   Сейчас используются только `ERR_FUNC_NOT_FOUND` и `ERR_INTERNAL`. Улучшение: расширить перечень кодов ошибок (например, «недопустимые аргументы», «таймаут исполнения функции», «недостаточно памяти»).  

4. **Изоляция FreeRTOS-логики**.  
   Сейчас транспорт напрямую использует очереди и семафоры. Улучшение: вынести это в отдельный модуль/адаптер, чтобы можно было заменить RTOS при необходимости.  

5. **Логирование и диагностика**.  
   Добавить отладочные сообщения в transport/link слои (например, через ESP-IDF logging), чтобы облегчить поиск проблем.  

6. **Тестирование**.  
   Сейчас есть только демонстрационные вызовы. Улучшение: добавить unit-тесты для CRC, фрейминга, state machine, а также интеграционные тесты для RPC.  

7. **Оптимизация памяти**.  
   Демонстрационные функции `sum` и `echo` выделяют новые буферы под каждый ответ. Для ресурсоограниченных устройств лучше использовать pre-allocated буфера или memory pool.  

8. **Обработка исключительных ситуаций**.  
   Сейчас задачи не защищены от некорректного ввода (например, слишком длинных имён функций). Улучшение: добавить защиту от переполнения буфера и явные лимиты.  

---

## Допущения в реализации

- **Один активный вызов**: сделано для упрощения логики и экономии ресурсов.  
- **CRC8**: оставлен в соответствии с текстом задания, несмотря на ограничения.  
- **ASCII-имена функций**: сохранены для наглядности, чтобы демонстрационный код легко читался и расширялся.  
- **Ответ освобождается транспортом**: выбранный контракт позволяет избежать двойного освобождения памяти и централизовать ответственность.  
- **Блокирующая модель `transport_call`**: сделана для простоты. Асинхронные вызовы потребовали бы более сложной архитектуры.  

---

## Заключение

Реализация показывает полный цикл RPC для микроконтроллера: от отправки байтов через UART до вызова функций верхнего уровня. Код разделён на слои, что упрощает модификацию и отладку. Несмотря на упрощения, проект может служить хорошей основой для дальнейшего развития протокола и практического использования в распределённых встроенных системах.
