Remote Procedure Call
Обзор

Этот проект реализует многоуровневый протокол Remote Procedure Call (RPC) для микроконтроллерной платформы ESP32. Протокол разделён на четыре слоя:

Физический слой – обеспечивает передачу байтов по UART. Реализация использует драйвер uart из ESP‑IDF и обеспечивает базовые функции physical_send и physical_receive_byte. Инициализация настраивает скорость, формат кадра (8N1) и пины TX/RX, после чего устанавливается драйвер UART. В тестовой конфигурации используется UART1 с пинами 17 (TX) и 16 (RX) и скоростью 115200.

Канальный слой – отвечает за фреймирование, контроль длины и контрольные суммы. Формат кадра выглядит так: [0xFA][len_lo][len_hi][crc_hdr][0xFB][payload][crc_full][0xFE].

Байты 0xFA и 0xFE отмечают начало и конец кадра, что помогает ресинхронизации при приёме.

Два байта длины задают размер полезной нагрузки.

crc_hdr – CRC‑8 от стартового байта и двух байтов длины.

0xFB – маркер начала данных.

crc_full – CRC‑8 по всем байтам от 0xFA до конца payload, включая crc_hdr и 0xFB.
link_send_frame формирует кадр, link_receive_frame реализует конечный автомат, который ищет стартовый байт, проверяет CRC и возвращает полезную нагрузку.

Транспортный слой – определяет формат сообщений RPC и диспетчеризует вызовы. Типы сообщений:

0x0B (Request) – запрос на вызов удалённой функции [type][counter][name ASCIIZ][args…].

0x0C (Stream) – зарезервировано для потоковых сообщений (не реализовано).

0x16 (Response) – успешный ответ [type][counter][data…].

0x21 (Error) – сообщение об ошибке [type][counter][error_code].
При отправке transport_call формирует Request, передаёт его в канальный слой и блокируется в ожидании ответа, используя семафор и очередь FreeRTOS. Счётчик counter позволяет сопоставить ответ с запросом. RX‑задача transport_receiver_task бесконечно принимает кадры из канального слоя, разбирает сообщения: для Request ищет обработчик по имени и вызывает его, для Response/Error – передаёт данные ожидающему transport_call.

Прикладной слой – содержит реальные удалённые процедуры. В примере определены функции:

sum – принимает 8 байт (два uint32_t в формате Little Endian), складывает их, преобразует сумму в десятичную строку и возвращает.

echo – копирует все полученные аргументы в ответ, добавляя '\0' как удобный терминатор.
Регистрация происходит в rpc_app_init через transport_register_function. Это позволяет вызывать функции по строковому имени. Главная точка входа app_main инициализирует все слои и запускает демо‑задачу, которая вызывает sum и echo для проверки работоспособности.

Управление памятью

Обработчики RPC возвращают данные через указатели resp_data/resp_len; память выделяется pvPortMalloc из heap FreeRTOS. Транспортный слой, после отправки ответа, освобождает буфер с помощью vPortFree. Клиент, получивший ответ через transport_call, обязан освободить буфер самостоятельно. В исходных функциях использовались malloc/free, что недопустимо на платформе ESP‑IDF. В финальной версии используется pvPortMalloc/vPortFree во всех слоях. Обработчики не освобождают буфер, чтобы избежать двойного освобождения: управление ресурсом переходит слою транспорта.

Недостатки и возможные улучшения протокола

Контрольная сумма CRC‑8 – 8‑битный CRC легко может пропустить некоторые ошибки. Следовало бы использовать более надёжный CRC‑16 или CRC‑32 либо хотя бы один CRC для всего кадра вместо двух CRC‑8. Кроме того, стоп‑байт и отдельный байт начала данных увеличивают накладные расходы, эти поля могли бы быть убраны благодаря использованию длины и одной контрольной суммы.

Строковые имена функций – использование нуль‑терминированных ASCII‑строк инициализирует задержки и накладные расходы. Более эффективно использовать короткие числовые идентификаторы (UInt16/UInt32) для RPC‑функций. Это сократит длину сообщения и ускорит поиск.

Версионирование и расширяемость – в текущем формате нет поля версии или флагов. Наличие одного байта version позволит эволюционировать протокол без ломки старых клиентов. Флаги позволят включать потоковые передачи или другие опции.

Только один активный запрос – транспортный слой поддерживает единственный pending_queue и не позволяет параллельных вызовов. Для полноценного RPC требовалась бы таблица ожиданий, где несколько запросов отличались бы счётчиком counter и каждой заявке соответствовала бы своя очередь или уведомление.

Нет полной поддержки сообщения типа 0x0C (Stream) – спецификация описывает потоковые сообщения, но код не реализует обработку и маршрутизацию потоковых данных. Следовало бы добавить отдельный API для работы с потоками (подписка, окна).

Формат аргументов и результатов – протокол передаёт данные как сырой набор байтов без описания типов. Для универсальности стоит разработать схемы сериализации (TLV, Protobuf, CBOR) либо передавать мета‑данные о типах.

Отсутствие таймаутов и повторов на канальном слое – если кадр потерян, то вызов просто висит до таймаута в transport_call. Можно добавить механизм повторной отправки или подтверждения на уровне канала.

Безопасность – протокол допускает вызов любых зарегистрированных функций, что может быть небезопасно. Следовало бы добавить механизм аутентификации и разрешений, фильтрацию имён и аргументов.

Возможные улучшения реализации

Поддержка нескольких одновременных вызовов – расширить transport.c, чтобы в нём хранилась таблица ожидающих вызовов counter → очередь, позволив параллельные RPC. Это потребует изменённого API (например, возвращать дескриптор операции или принимать callback).

Унификация аллокатора – следить, чтобы во всех слоях использовались pvPortMalloc/vPortFree либо собственный пул. Можно добавить отладочные хуки, учитывающие размер буфера и необходимость освобождения.

Чёткое перечисление кодов ошибок – протокол определяет всего два кода (ERR_FUNC_NOT_FOUND, ERR_INTERNAL). Следовало бы расширить перечень ошибок: неверный аргумент, перегрузка сервера, неверная CRC, таймаут и т.д., и документировать их.

Конфигурируемый формат – вынести параметры (скорость UART, размер буферов, полином CRC, start/stop байты) в Kconfig или конфигурационный заголовок, чтобы их можно было менять без перекомпиляции.

Асинхронные обработчики и прерывание – приём кадра и вызов callback сейчас происходят в RX‑задаче. Долгие вычисления могут задерживать приём новых сообщений. Возможность делегировать обработку в отдельную очередь позволит улучшить отзывчивость.

Разделение ответственности – вынести код регистрации и реализацию RPC‑функций в отдельные файлы/модули, описать интерфейс для динамического добавления и удаления функций. Это упростит поддержку и расширение.

Тестирование – добавить юнит‑тесты для каждого уровня: тесты CRC, тесты finite‑state‑machine фрейминга, тесты на правильность сериализации/десериализации, на параллельные вызовы.

Проект в текущем виде представляет базовую реализацию RPC‑протокола для ESP‑IDF, которую можно использовать как отправную точку и расширять по мере необходимости. Улучшения, предложенные выше, позволят повысить надёжность, производительность и удобство использования. Сделанные допущения (один активный вызов, CRC‑8, строковые имена) упрощают реализацию и позволяют сконцентрироваться на механике протокола, но накладывают ограничения и могут быть сняты в следующих версиях.
